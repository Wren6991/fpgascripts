#!/usr/bin/env python3

"""Convert a .bin file to a 32-bit-wide AHB ROM."""

import argparse
import math
import os.path
import struct
import sys

parser = argparse.ArgumentParser()
parser.add_argument("src", help="Source binary file")
parser.add_argument("dst", help="Destination verilog file")
parser.add_argument("--asize", "-a", help="Address bus size (default 32)", type=int, default=32)
parser.add_argument("--outreg", action="store_true", help="Insert registers on output (adds one wait state).")
parser.add_argument("--reproducible", help="Don't put build-dependent information in the output, e.g. absolute paths")
args = parser.parse_args()

module_name = os.path.basename(args.dst).split(".")[0]

rom_bytes = open(args.src, "rb").read()
if len(rom_bytes) == 0:
	sys.exit("Input file is empty. Try again dumbass.")
if len(rom_bytes) % 4 != 0:
	rom_bytes = rom_bytes + bytes(4 - len(rom_bytes) % 4)
rom_words = list(w[0] for w in struct.iter_unpack("<L", rom_bytes))

rom_text = "\n".join(f"\t{args.asize}'h{i * 4:x}: rom_rdata = 32'h{w:08x};"
	for i, w in enumerate(rom_words))

output_assign_comb = """
assign ahbls_hready_resp = 1'b1;
assign ahbls_hresp = 1'b0;
assign ahbls_hrdata = rom_rdata;
"""

output_assign_sync = """
reg ready;
always @ (posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		ready <= 1'b1;
	end else if (ahbls_hready && ahbls_htrans[1]) begin
		ready <= 1'b0;
	end else begin
		ready <= 1'b1;
	end
end

reg [31:0] q;
always @ (posedge clk) begin
	q <= rom_rdata;
end

assign ahbls_hresp = 1'b0;
assign ahbls_hready_resp = ready;
assign ahbls_hrdata = q;
"""

rom_src = f"""// Generated by bin2rom, do not modify directly.
// Source: {args.src if args.reproducible else os.path.abspath(args.src)}

`default_nettype none

module {module_name} (
	input  wire        clk,
	input  wire        rst_n,
	
	// AHB-Lite Port
	input  wire [{args.asize-1}:0] ahbls_haddr,
	input  wire [1:0]  ahbls_htrans,
	input  wire        ahbls_hwrite,
	input  wire [2:0]  ahbls_hsize,
	input  wire        ahbls_hready,
	output wire        ahbls_hready_resp,
	input  wire [31:0] ahbls_hwdata,
	output wire [31:0] ahbls_hrdata,
	output wire        ahbls_hresp
);

localparam [{args.asize-1}:0] ADDR_MASK = {args.asize}'h{(2 ** math.ceil(math.log2(len(rom_words))) - 1) * 4:x};

reg [{args.asize-1}:0] addr_q;
wire [{args.asize-1}:0] addr = addr_q & ADDR_MASK;

always @ (posedge clk) if (ahbls_htrans[1] && ahbls_hready) begin
	addr_q <= ahbls_haddr & ADDR_MASK;
end

reg [31:0] rom_rdata;
always @ (*) case (addr)
{rom_text}
	default: rom_rdata = 32'h00000000;
endcase
{output_assign_sync if args.outreg else output_assign_comb}
endmodule

`ifndef YOSYS
`default_nettype wire
`endif
"""

open(args.dst, "w").write(rom_src)